<!DOCTYPE html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://hysteria2.github.io/news/article-22902.htm" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- Webpage Title -->
    <title>Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）</title>
        <meta name="description" content="什么是树表查询？ 借助具有特殊性质的树数据结构进行关键字查找。 本文所涉及到的特殊结构性质的树包括：  二叉排序树。 平衡二叉树。  使用上述树结构存储数据时，因其本身对结点之间的关系以及顺序有特殊要" />
        <link rel="icon" href="/assets/website/img/hysteria2/favicon.ico" type="image/x-icon"/>
    <!-- Styles -->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
    <link href="/assets/website/css/hysteria2/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/website/css/hysteria2/fontawesome-all.min.css" rel="stylesheet">
    <link href="/assets/website/css/hysteria2/swiper.css" rel="stylesheet">
    <link href="/assets/website/css/hysteria2/styles.css" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0LQ0YHE09L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0LQ0YHE09L');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-bs-spy="scroll" data-bs-target="#navbarExample" data-page="detail">
        <!-- Navigation -->
    <nav id="navbarExample" class="navbar navbar-expand-lg fixed-top navbar-light" aria-label="Main navigation">
        <div class="container">
            <!-- Image Logo -->
                        <a class="navbar-brand logo-image" href="/">
                Hysteria2节点
            </a>
                        <!-- Text Logo - Use this if you don't have a graphic logo -->
            <!-- <a class="navbar-brand logo-text" href="index.html">Zinc</a> -->
            <button class="navbar-toggler p-0 border-0" type="button" id="navbarSideCollapse" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="navbar-collapse offcanvas-collapse" id="navbarsExampleDefault">
                <ul class="navbar-nav ms-auto navbar-nav-scroll">
                                        <li class="nav-item">
                        <a class="nav-link" href="/">首页</a>
                    </li>
                                        <li class="nav-item">
                        <a class="nav-link" href="/free-nodes/">免费节点</a>
                    </li>
                                        <li class="nav-item">
                        <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                    </li>
                                        <li class="nav-item">
                        <a class="nav-link" href="/news/">新闻资讯</a>
                    </li>
                                        <li class="nav-item">
                        <a class="nav-link" href="#">关于</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">联系</a>
                    </li>
                </ul>
            </div> <!-- end of navbar-collapse -->
        </div> <!-- end of container -->
    </nav> <!-- end of navbar -->
    <!-- end of navigation -->
    <!-- Header -->
    <header class="ex-header">
        <div class="container">
            <div class="row">
                <div class="col-xl-10 offset-xl-1">
                    <h1>Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）</h1>
                    <div class="section-title">
                        <a href="/">首页</a> / <a href="/news/">新闻资讯</a> / <span>正文</span>
                    </div>
                </div> <!-- end of col -->
            </div> <!-- end of row -->
        </div> <!-- end of container -->
    </header> <!-- end of ex-header -->
    <!-- end of header -->
    <!-- Details 1 -->
    <div id="details" class="basic-1">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<p><strong>什么是树表查询？</strong></p> <p>借助具有<code>特殊</code>性质的<code>树数据结构</code>进行关键字查找。</p> <p>本文所涉及到的特殊结构性质的树包括：</p> <ul> <li><code>二叉排序树</code>。</li> <li><code>平衡二叉树</code>。</li> </ul> <p>使用上述<code>树结构</code>存储数据时，因其本身对结点之间的关系以及顺序有特殊要求，也得益于这种限制，在查询某一个结点时会带来性能上的优势和操作上的方便。</p> <p>树表查询属于<code>动态查找</code>算法。</p> <p>所谓<code>动态查找</code>，不仅仅能很方便查询到目标结点。而且可以根据需要添加、删除结点，而不影响树的整体结构，也不会影响数据的查询。</p> <blockquote> <p>本文并不会深入讲解<code>树数据结构</code>的基本的概念，仅是站在使用的角度说清楚动态查询。阅读此文之前，请预备一些树的基础知识。</p> </blockquote> <h2 id="1-二叉排序树">1. 二叉排序树</h2> <p><code>二叉树</code>是树结构中具有艳明特点的子类。</p> <p><code>二叉树</code>要求树的每一个结点（除叶结点）的子结点最多只能有<code>2</code> 个。在<code>二叉树</code>的基础上，继续对其进行有序限制则变成<code>二叉排序树</code>。</p> <p><strong>二叉排序树特点：</strong></p> <p>基于<code>二叉树</code>结构，从根结点开始，从上向下，每一个父结点的值大于左子结点（如果存在左子结点）的值，而小于右子结点（如果存在右子结点）的值。则把符合这种特征要求的树称为<code>二叉排序树</code>。</p> <h3 id="11-构建一棵二叉排序树">1.1 构建一棵<code>二叉排序树</code></h3> <p>如有数列<code>nums=[5,12,4,45,32,8,10,50,32,3]</code>。通过下面流程，把每一个数字映射到<code>二叉排序树</code>的结点上。</p> <ol> <li>如果树为空，把第一个数字作为根结点。如下图，数字<code>5</code> 作为根结点。</li> </ol> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/8fc2502a795b1a5cc759ed54adf09f51.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <ol start="2"> <li>如果已经存在根结点，则把数字和根结点比较，小于根结点则作为根结点的左子结点，大于根结点的作为根结点的右子结点。如数字<code>4</code> 插入到左边，数字<code>12</code> 插入到右边。</li> </ol> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/a3a9f81f2b188bc3f91695a3c2421075.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <ol start="3"> <li>数列中后面的数字依据相同法则，分别插入到不同子的位置。</li> </ol> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/747df20e162747b3265869f81436606b.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>原始数列中的数字是无序的，根据<code>二叉排序树</code>的插入算法，最终可得到一棵有排序性质的树结构。对此棵树进行<code>中序遍历</code>就可得到从小到大的一个递增有序数列。</p> <p>综观<code>二叉排序树</code>，进行关键字查找时，也应该是接近于二分查找算法的时间度。</p> <blockquote> <p>这里有一个要注意的地方。</p> <p>原始数列中的数字顺序不一样时，生成的二叉排序树的结构也会有差异性。对于查找算法的性能会产生影响。</p> </blockquote> <h3 id="12-二叉排序树的数据结构">1.2 二叉排序树的数据结构</h3> <p>现在使用<code>OOP</code>设计方案描述二叉排序树的数据结构。</p> <p>首先，设计一个<strong>结点类</strong>，用来描述结点本身的信息。</p> <pre><code class="language-python">''' 二叉排序树的结点类 ''' class TreeNode():     def __init__(self, value):         # 结点上的值         self.value = value         # 左结点         self.l_child = None         # 右结点         self.r_child = None</code></pre> <p>结点类中有<code>3</code> 个属性：</p> <ul> <li><code>value</code>：结点上附加的数据信息。</li> <li><code>l_child</code>：左子结点，初始值为<code>None</code> 。</li> <li><code>r_child</code>：右子结点，初始值为<code>None</code>。</li> </ul> <p><strong>二叉排序树类：</strong> 用来实现树的增、删、改、查。</p> <pre><code class="language-python">''' 二叉排序树类 ''' class BinarySortTree:     # 初始化树     def __init__(self, value=None):         pass          '''     在整棵树上查询是否存在给定的关键字     '''     def find(self, key):         pass          '''     使用递归进行查询     '''     def find_dg(self, root, key):         pass      '''     插入新结点     '''     def insert(self, value):         pass       '''     中序遍历     '''     def inorder_traversal(self):         pass     '''     删除结点     '''     def delete(self, key):         pass      '''     检查是不是空树     '''     def is_empty(self):         return self.root == None</code></pre> <blockquote> <p>二叉排序树中可以有更多方法，本文只关注与查找主题有关的方法。</p> </blockquote> <h3 id="13-实现二叉排序树类中的方法">1.3 实现二叉排序树类中的方法：</h3> <p><strong><code>__init__</code> 初始化方法：</strong></p> <pre><code class="language-python">    # 初始化树     def __init__(self, value=None):         self.root = None         if value is not None:             root_node = TreeNode(value)             self.root = root_node</code></pre> <p>在初始化树对象时，如果指定了数据信息，则创建有唯一结点的树，否则创建一个空树。</p> <p><strong>关键字查询方法</strong>：查询给定的关键字在二叉排序树结构中是否存在。</p> <p>查询流程：</p> <ul> <li>把给定的关键字和根结点相比较。如果相等，则返回查找成功，结束查询.</li> <li>如果根结点的值大于关键字，则继续进入根结点的左子树中开始查找。</li> <li>如果根结点的值小于关键字，则进入根结点的右子树中开始查找。</li> <li>如果没有查询到关键字，则返回最后访问过的结点和查询不成功信息。</li> </ul> <p>关键字查询的本质是二分思想，以当前结点为分界线，然后向左或向右进行分枝查找。</p> <p><strong>非递归实现查询方法：</strong></p> <pre><code class="language-python">    '''     在整棵树上查询是否存在给定的关键字     key: 给定的关键字     '''     def find(self, key):         # 从根结点开始查找。         move_node = self.root         # 用来保存最后访问过的结点         last_node = None         while move_node is not None:             # 保存当前结点             last_node = move_node             # 把关键字和当前结点相比较             if self.root.value == key:                 # 出口一：成功查找                 return move_node             elif move_node.value &gt; key:                 # 在左结点查找                 move_node = move_node.l_child             else:                 # 在右结点中查找                 move_node = move_node.r_child         # 出口二：如果没有查询到，则返回最后访问过的结点及None（None 表示没查询到）         return last_node, None</code></pre> <blockquote> <p>注意：当没有查询到时，返回的值有<code>2</code> 个，最后访问的结点和没有查询到的信息。</p> <p>为什么要返回最后一次访问过的结点？</p> <p>反过来想想，本来应该在这个地方找到，但是没有，如果改成插入操作，就应该插入到此位置。</p> </blockquote> <p><strong>基于递归实现的查找：</strong></p> <pre><code class="language-python">    '''     使用递归进行查询     '''     def find_dg(self, root, key):         # 结点不存在         if root is None:             return None         # 相等         if root.value == key:             return root         if root.value &gt; key:             return self.find_dg(root.l_child, key)         else:             return self.find_dg(root.r_child, key)</code></pre> <p>再看看如何把数字插入到二叉排序树中，利用二叉排序树进行查找的前提条件就是要把数字映射到二叉排序树的结点上。</p> <p>插入结点的流程：</p> <ul> <li>当需要插入某一个结点时，先搜索是否已经存在于树结构中。</li> <li>如果没有，则获取到查询时访问过的最一个结点，并和此结点比较大小。</li> <li>如果比此结点大，则插入最后访问过结点的右子树位置。</li> <li>如果比此结点小，则插入最后访问过结点的左子树位置。</li> </ul> <p><strong><code>insert</code> 方法的实现：</strong></p> <pre><code class="language-python">    '''     插入新结点     '''     def insert(self, value):         # 查询是否存在此结点         res = self.find(value)         if type(res) != TreeNode:             # 没找到，获取查询时最后访问过的结点             last_node = res[0]             # 创建新结点             new_node = TreeNode(value)             # 最后访问的结点是根结点             if last_node is None:                 self.root = new_node             if value &gt; last_node.value:                 last_node.r_child = new_node             else:                 last_node.l_child = new_node</code></pre> <pre><code>怎么检查插入的结点是符合二叉树特征？</code></pre> <p>再看一下前面根据插入原则手工绘制的插入演示图：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/5b214d5270e9df568d48b92dbce204a5.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>上图有<code>4</code> 个子结点，写几行代码测试一下，看从根结点到叶子结点的顺序是否正确。</p> <p><strong>测试插入方法：</strong></p> <pre><code class="language-python">if __name__ == "__main__":     nums = [5, 12, 4, 45, 32, 8, 10, 50, 32, 3]     tree = BinarySortTree(5)     for i in range(1, len(nums)):         tree.insert(nums[i])     print("测试根5 -&gt; 左4 -&gt;左3:")     tmp_node = tree.root     while tmp_node != None:         print(tmp_node.value, end=" -&gt;")         tmp_node = tmp_node.l_child     print("\n测试根5 -&gt; 右12 -&gt;右45-&gt;右50：")     tmp_node = tree.root     while tmp_node != None:         print(tmp_node.value, end=" -&gt;")         tmp_node = tmp_node.r_child     '''     输出结果：     测试根5 -&gt; 左4 -&gt;左3: 	5 -&gt;4 -&gt;3 -&gt; 	测试根5 -&gt; 右12 -&gt;右45-&gt;右50： 	5 -&gt;12 -&gt;45 -&gt;50 -&gt;	     '''</code></pre> <p>查看结果，可以初步判断插入的数据是符合二叉排序树特征的。当然，更科学的方式是写一个遍历方法。树的遍历方式有<code>3</code> 种：</p> <ul> <li>前序：根，左，右。</li> <li>中序：左，根，右。</li> <li>后序。左，右，根。</li> </ul> <p>对<code>二叉排序树</code>进行中序遍历，理论上输出的数字应该是有序的。这里写一个中序遍历，查看输出的结点是不是有序的，从而验证查询和插入方法的正确性。</p> <p>使用递归实现中序遍历：</p> <pre><code class="language-python">    '''     中序遍历     '''     def inorder_traversal(self, root):         if root is None:             return         self.inorder_traversal(root.l_child)         print(root.value,end="-&gt;")         self.inorder_traversal(root.r_child)</code></pre> <p>测试插入的顺序：</p> <pre><code class="language-python">if __name__ == "__main__":     nums = [5, 12, 4, 45, 32, 8, 10, 50, 32, 3]     tree = BinarySortTree(5)     # res = tree.find(51)     for i in range(1, len(nums)):         tree.insert(nums[i])     tree.inorder_traversal(tree.root)    '''    输出结果    3-&gt;4-&gt;5-&gt;8-&gt;10-&gt;12-&gt;32-&gt;45-&gt;50-&gt;    '''</code></pre> <p>二叉排序树很有特色的数据结构，利用其存储特性，可以很方便地进行查找、排序。并且随时可添加、删除结点，而不会影响排序和查找操作。基于树表的查询操作称为动态查找。</p> <p><strong>二叉排序树中如何删除结点</strong></p> <p>从二叉树中删除结点，需要保证整棵二叉排序树的有序性依然存在。删除操作比插入操作要复杂，下面分别讨论。</p> <ol> <li>如果要删除的结点是叶子结点。</li> </ol> <p>只需要把要删除结点的父结点的左结点或右结点的引用值设置为空就可以了。</p> <ol start="2"> <li>删除的结点只有一个右子结点。如下图删除结点<code>8</code>。</li> </ol> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/c339934f42c675dbcebbe9be8d95679b.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>因为结点<code>8</code>没有左子树，在删除之后，只需要把它的右子结点替换删除结点就可以了。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/f916754516e2e4c5d1f1df9a20531b5d.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <ol start="3"> <li>删除的结点即存在左子结点，如下图删除值为<code>25</code> 的结点。</li> </ol> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/24820229e97d59fb88fcf7ce59a92e7c.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p><strong>一种方案是</strong>：找到结点<code>25</code> 的左子树中的最大值，即结点<code>20</code>（该结点的特点是可能会存在左子结点，但一定不会有右子结点）。用此结点替换结点<code>25</code> 便可。</p> <blockquote> <p>为什么要这么做？</p> <p>道理很简单，既然是左子树中的最大值，替换删除结点后，整个二叉排序树的特性可以继续保持。</p> </blockquote> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/2adcbeeb4d393fbf48c83d6c3210113f.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>如果结点<code>20</code> 存在左子结点，则把它的左子结点作为结点<code>18</code>的右子结点。</p> <p><strong>另一种方案</strong>：同样找到结点<code>25</code>中左子树中的最大值结点<code>20</code>，然后把结点<code>25</code> 的右子树作为结点<code>20</code> 的右子树。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/fbf54f33002e9f6db6d1ff7a7cf29791.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>再把结点<code>25</code> 的左子树移到<code>25</code> 位置。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/57f3a571aa8ecaf951ce0e8f12ed155b.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>这种方案会让树增加树的深度。所以，建议使用第一种方案。</p> <p><strong>删除方法的实现：</strong></p> <pre><code class="language-python"> 	'''     删除结点     key 为要要删除的结点     '''     def delete(self, key):         # 从根结点开始查找，move_node 为搜索指针         move_node = self.root         # 要删除的结点的父结点,因为根结点没有父结点，初始值为 None         parent_node = None         # 结点存在且没有匹配上要找的关键字         while move_node is not None and move_node.value != key:             # 保证当前结点             parent_node = move_node             if move_node.value &gt; key:                 # 在左子树中继续查找                 move_node = move_node.l_child             else:                 # 在右子树中继续查找                 move_node = move_node.r_child         # 如果不存在         if move_node is None:             return -1         # 检查要删除的结点是否存在左子结点         if move_node.l_child is None:             if parent_node is None:                 # 如果要删除的结点是根结点                 self.root = move_node.r_child             elif parent_node.l_child == move_node:                 # 删除结点的右结点作为父结点的左结点                 parent_node.l_child = move_node.r_child             elif parent_node.r_child == move_node:                 parent_node.r_child = move_node.r_child             return 1         else:             # 如果删除的结点存在左子结点,则在左子树中查找最大值             s = move_node.l_child             q = move_node             while s.r_child is not None:                 q = s                 s = s.r_child             if q == move_node:                 move_node.l_child = s.l_child             else:                 q.r_child = s.l_child             move_node.value = s.value             q.r_child = None             return 1</code></pre> <p>测试删除后的二叉树是否依然维持其有序性。</p> <pre><code class="language-python">if __name__ == "__main__":     nums = [5, 12, 4, 45, 32, 8, 10, 50, 32, 3]     tree = BinarySortTree(5)     # res = tree.find(51)     for i in range(1, len(nums)):         tree.insert(nums[i])     tree.delete(12)     tree.inorder_traversal(tree.root)     '''     输出结果     3-&gt;4-&gt;5-&gt;8-&gt;10-&gt;32-&gt;45-&gt;50-&gt;     '''</code></pre> <p>无论删除哪一个结点，其二叉排序树的中序遍历结果都是有序的，很好地印证了删除算法的正确性。</p> <h2 id="3-平衡二叉排序树">3. 平衡二叉排序树</h2> <p><code>二叉排序树</code>中进行查找时，其<code>时间复杂度</code>理论上接近<code>二分算法</code>的时间复杂度，其查找时间与树的深度有关。但是，这里有一个问题，前面讨论过，如果数列中的数字顺序不一样时，所构建出来的二叉排序树的深度会有差异性，对最后评估时间性能也会有影响。</p> <p>如有数列<code>[36,45,67,28,20,40]</code>构建的二叉排序树如下图：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/26b17e594b36e1706de31e6629ea772e.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>基于上面的树结构，查询任何一个结点的次数不会超过<code>3</code> 次。</p> <p>稍调整一下数列中数字的顺序<code>[20,28,36,40,45,67]</code>，由此构建出来的树结构会出现一边倒的现象，也增加了树的深度。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/310f86076b5cab63e12697a632ba9e73.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>此棵树的深度为<code>6</code>，最多查询次数是<code>6</code> 次。在二叉排序树中，减少查找次数的最好办法，就是尽可能维护树左右子树之间的对称性，也就让其有平衡性。</p> <p>所谓平衡二叉排序树，顾名思义，基于二叉排序树的基础之上，维护任一结点的左子树和右子树之间的深度之差不超过<code>1</code>。把二叉树上任一结点的左子树深度减去右子树深度的值称为该结点的平衡因子。</p> <p>平衡因子只可能是:</p> <ul> <li><code>0</code> ：左、右子树深度一样。</li> <li><code>1</code>：左子树深度大于右子树。</li> <li><code>-1</code>：左子树深度小于右子树。</li> </ul> <p>如下图，就是<code>平衡二叉排序树</code>，根结点的<code>2</code> 个子树深度相差为<code>0</code>， 结点<code>28</code> 的左、右子树深度为 1，结点<code>45</code> 的左右子树深度相差为<code>0</code>。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/47ca76dd4261a7d1ed09e2b3578a27fb.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>平衡二叉排序树相比较于二叉排序树，其<code>API</code> 多了保持平衡的算法。</p> <h3 id="31--二叉平衡排序树的数据结构">3.1  二叉平衡排序树的数据结构</h3> <p><strong>结点类：</strong></p> <pre><code class="language-python">''' 结点类 ''' class TreeNode:     def __init__(self,value):         self.value=value         self.l_child=None         self.r_child=None         self.balance=0</code></pre> <p>结点类中有<code>4</code> 个属性：</p> <ul> <li><code>value</code>：结点上附加的值。</li> <li><code>l_child</code>：左子结点。</li> <li><code>r_child</code>：右子结点。</li> <li><code>balance</code>：平衡因子，默认平衡因子为<code>0</code>。</li> </ul> <p><strong>二叉平衡排序树类：</strong></p> <pre><code class="language-python">''' 树类 ''' class Tree:     def __init__(self, value):         self.root = None      '''     LL型调整     '''     def ll_rotate(self, node):         pass      '''     RR 型调整     '''     def rr_rotate(self, node):         pass      '''     LR型调整     '''     def lr_rotate(self, node):         pass      '''     RL型调整     '''     def rl_rotate(self, node):         pass      '''     插入新结点     '''     def insert(self, value):         pass          '''     中序遍历     '''     def inorder_traversal(self, root):         pass      def is_empty(self):         pass</code></pre> <p>在插入或删除结点时，如果导致树结构发生了不平衡性，则需要调整让其达到平衡。这里的方案可以有<code>4</code>种。</p> <p><code>LL型调整（顺时针）</code>：<strong>左边不平衡时，向右边旋转。</strong></p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/2ab8a021dc7029afd011e4af5d163ae9.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>如上图，现在根结点<code>36</code> 的平衡因子为<code>1</code>。如果现插入值为<code>18</code> 结点，显然要作为结点<code>20</code> 的左子结点，才符合二叉排序树的有序性。但是破坏了根结点的平衡性。根结点的左子树深度变成<code>3</code>，右子树深度为<code>1</code>，平衡被打破，结点<code>36</code> 的平衡因子变成了<code>2</code>。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/3c2956a4c1533d5269b06008cc566d1a.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>这里可以使用<code>顺时针</code>旋转方式，让其继续保持平衡，旋转流程：</p> <ul> <li>让结点<code>28</code> 成为新根结点，结点<code>36</code>成为结点<code>28</code>的左子结点。</li> <li>结点<code>29</code>成为结点<code>36</code>的新左子结点。</li> </ul> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/af79b5b03e3a145af7770c273446553a.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>旋转后，树结构即满足了有序性，也满足了平衡性。</p> <p><code>LL</code> 旋转算法具体实现：</p> <pre><code class="language-python">    '''     LL型调整     顺时针对调整     '''     def ll_rotate(self, p_root):         # 原父结点的左子结点成为新父结点         new_p_root = p_root.l_child         # 新父结点的右子结点成为原父结点的左子结点         p_root.l_child = new_p_root.r_child         # 原父结点成为新父结点的右子结点         new_p_root.r_child = p_root         # 重置平衡因子         p_root.balance = 0         new_p_root.balance = 0         return new_p_root</code></pre> <p><code>RR 型调整(逆时针旋转)</code>：<code>RR</code>旋转和<code>LL</code>旋转的算法差不多，只是当右边不平衡时，向左边旋转。</p> <p>如下图所示，结点<code>50</code> 插入后，树的平衡性被打破。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/e3e417c9ed4e9aa953c425069ab9483d.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>这里使用左旋转（逆时针）方案。结点<code>36</code> 成为结点<code>45</code> 的左子结点，结点<code>45</code> 原来的左子结点成为结点<code>36</code>的右子结点。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/5f3a81322987afe0b30fac27de58111f.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>向逆时针旋转后，结点<code>45</code>的平衡因子为<code>0</code>，结点<code>36</code>的平衡因子为<code>0</code>，结点<code>48</code> 的平衡因子为<code>-1</code>。树的有序性和平衡性得到保持。</p> <p><code>RR</code> 旋转算法具体实现：</p> <pre><code class="language-python">    '''     RR 型调整     '''     def rr_rotate(self, node):         # 右子结点         new_p_node = p_node.r_child         p_node.r_child = new_p_node.l_child         new_p_node.l_child = p_node         # 重置平衡因子         p_node.balance = 0         new_p_node.balance = 0         return new_p_node</code></pre> <p><strong><code>LR型调整（先逆后顺）</code>：</strong>如下图当插入结点<code>28</code> 后，结点<code>36</code> 的平衡因子变成<code>2</code>，则可以使用<code>LR</code> 旋转算法。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/0deedf74a1046d6fa762b38a04f21fbd.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>以结点<code>29</code> 作为新的根结点，结点<code>27</code>以结点<code>29</code>为旋转中心，逆时针旋转。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/bd8dd9dba193d93b05791c24d1a79a63.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>结点<code>36</code>以结点<code>29</code>为旋转中心向顺时针旋转。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/d79ca77371f65a766fd6bc46fd2a35fa.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>最后得到的树还是一棵<code>二叉平衡排序树</code>。</p> <p><code>LR</code> 旋转算法实现：</p> <pre><code class="language-python">    '''     LR型调整     '''     def lr_rotate(self, p_node):         # 左子结点         b = p_node.l_child         new_p_node = b.r_child         p_node.l_child = new_p_node.r_child         b.r_child = new_p_node.l_child         new_p_node.l_child = b         new_p_node.r_child = p_node         if new_p_node.balance == 1:             p_node.balance = -1             b.balance = 0         elif new_p_node.balance == -1:             p_node.balance = 0             b.balance = 1         else:             p_node.balance = 0             b.balance = 0         new_p_node.balance = 0         return new_p_node</code></pre> <p><strong><code>RL</code>型调整：</strong> 如下图插入结点<code>39</code> 后，整棵树的平衡打破，这时可以使用<code>RL</code> 旋转算法进行调整。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/0ef3a496642d81b744569618577c40f9.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p>把结点<code>40</code>设置为新的根结点，结点<code>45</code>以结点<code>40</code> 为中心点顺时针旋转，结点<code>36</code>逆时针旋转。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/86fe592bbf8a12285d3deb2af0ebefd3.jpg" alt="Python 树表查找_千树万树梨花开，忽如一夜春风来（二叉排序树、平衡二叉树）"></p> <p><strong><code>RL</code> 算法具体实现：</strong></p> <pre><code class="language-python">    '''     RL型调整     '''     def rl_rotate(self, p_node):         b = p_node.r_child         new_p_node = b.l_child         p_node.r_child = new_p_node.l_child         b.l_child = new_p_node.r_child         new_p_node.l_child = p_node         new_p_node.r_child = b         if new_p_node.balance == 1:             p_node.balance = 0             b.balance = -1         elif new_p_node.balance == -1:             p_node.balance = 1             b.balance = 0         else:             p_node.balance = 0             b.balance = 0         new_p_node.balance = 0         return new_p_node</code></pre> <p>编写完上述算法后，就可以编写插入算法。在插入新结点时，检查是否破坏二叉平衡排序树的的平衡性，否则调用平衡算法。</p> <blockquote> <p>当插入一个结点后，为了保持平衡，需要找到最小不平衡子树。</p> <p>什么是最小不平衡子树？</p> <p>指离插入结点最近，且平衡因子绝对值大于<code>1</code> 的结点为根结点构成的子树。</p> </blockquote> <pre><code class="language-python">    '''     插入新结点     '''     def insert(self, val):         # 新的结点         new_node = TreeNode(val)         if self.root is None:             # 空树             self.root = new_node             return         # 记录离 s 最近的平衡因子不为 0 的结点。         min_b = self.root         # f 指向 a 的父结点         f_node = None         move_node = self.root         f_move_node = None         while move_node is not None:             if move_node.value == new_node.value:                 # 结点已经存在                 return             if move_node.balance != 0:                 # 寻找最小不平衡子树                 min_b = move_node                 f_node = f_move_node             f_move_node = move_node             if new_node.value &lt; move_node.value:                 move_node = move_node.l_child             else:                 move_node = move_node.r_child          if new_node.value &lt; f_move_node.value:             f_move_node.l_child = new_node         else:             f_move_node.r_child = new_node         move_node = min_b         # 修改相关结点的平衡因子         while move_node != new_node:             if new_node.value &lt; move_node.value:                 move_node.balance += 1                 move_node = move_node.l_child             else:                 move_node.balance -= 1                 move_node = move_node.r_child          if min_b.balance &gt; -2 and min_b.balance &lt; 2:             # 插入结点后没有破坏平衡性             return          if min_b.balance == 2:             b = min_b.l_child             if b.balance == 1:                 move_node = self.ll_rotate(min_b)             else:                 move_node = self.lr_rotate(min_b)         else:             b = min_b.r_child             if b.balance == 1:                 move_node = self.rl_rotate(min_b)             else:                 move_node = self.rr_rotate(min_b)         if f_node is None:             self.root = move_node         elif f_node.l_child == min_b:             f_node.l_child = move_node         else:             f_node.r_child = move_node</code></pre> <p><strong>中序遍历：</strong> 此方法为了验证树结构还是排序的。</p> <pre><code class="language-python">    '''     中序遍历     '''     def inorder_traversal(self, root):         if root is None:             return         self.inorder_traversal(root.l_child)         print(root.value, end="-&gt;")         self.inorder_traversal(root.r_child)</code></pre> <p>二叉平衡排序树本质还是二树排序树。如果使用中序遍历输出的数字是有序的。测试代码。</p> <pre><code class="language-python">if __name__ == "__main__":     nums = [3, 12, 8, 10, 9, 1, 7]     tree = Tree(3)     for i in range(1, len(nums)):         tree.inster(nums[i])     # 中序遍历         tree.inorder_traversal(tree.root)     '''     输出结果     1-&gt;3-&gt;7-&gt;8-&gt;9-&gt;10-&gt;12-&gt;     '''</code></pre> <h2 id="4-总结">4. 总结</h2> <p>利用<code>二叉排序树</code>的特性，可以实现<code>动态查找</code>。在添加、删除结点之后，理论上查找到某一个结点的时间复杂度与树的结点在树中的深度是相同的。</p> <p>但是，在构建二叉排序树时，因原始数列中数字顺序的不同，则会影响二叉排序树的深度。</p> <p>这里引用二叉平衡排序树，用来保持树的整体结构是平衡，方能保证查询的时间复杂度为<code>Ologn</code>(<code>n</code> 为结点的数量)。</p> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-22446.htm">成都宠物疫苗防疫站（成都宠物疫苗防疫站电话）</a></p>
                                        <p>下一个：<a href="/news/article-22903.htm">宠物医师资格证可以自考吗（可以考宠物医生执照吗）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-11-3-free-v2ray-subscribe.htm" title="11月3日|最高速度19.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">11月3日|最高速度19.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-1-free-node-subscribe.htm" title="6月1日|最高速度18.3M/S，2024最新Clash/Shadowrocket/SSR/V2ray免费节点高速订阅链接">6月1日|最高速度18.3M/S，2024最新Clash/Shadowrocket/SSR/V2ray免费节点高速订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-24527.htm" title="宠物寄养管理办法最新（宠物寄养规章制度）">宠物寄养管理办法最新（宠物寄养规章制度）</a></li>
                        <li class="py-2"><a href="/news/article-22446.htm" title="成都宠物疫苗防疫站（成都宠物疫苗防疫站电话）">成都宠物疫苗防疫站（成都宠物疫苗防疫站电话）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-21-free-node-subscribe-links.htm" title="11月21日|最高速度19.4M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">11月21日|最高速度19.4M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-7-free-node-subscribe.htm" title="12月7日|最高速度23M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">12月7日|最高速度23M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-6-clash-node.htm" title="11月6日|最高速度19.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">11月6日|最高速度19.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-10-16-clash-windows.htm" title="10月16日|最高速度22.8M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">10月16日|最高速度22.8M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-15-free-subscribe-node.htm" title="11月15日|最高速度21.5M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">11月15日|最高速度21.5M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-13-clash-node-daily-updates.htm" title="11月13日|最高速度21.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐">11月13日|最高速度21.3M/S，2024最新Hysteria2免费节点高速订阅链接，便宜机场推荐</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">3</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">34</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-10/" title="2024-10 归档">2024-10</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-09/" title="2024-09 归档">2024-09</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">26</span> <a href="/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">29</span> <a href="/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">25</span> <a href="/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                    </ul>
    </div>
</div>


                </div>
            </div>
        </div> <!-- end of container -->
    </div> <!-- end of basic-1 -->
    <!-- end of details 1 -->
    
        <!-- Copyright -->
    <div class="copyright bg-gray">
        <div class="container">
            <div class="row">
                <div class="col-lg-6">
                    <ul class="list-unstyled li-space-lg p-small">
                        <li><a href="#">Article Details</a></li>
                        <li><a href="#">Terms & Conditions</a></li>
                        <li><a href="#">Privacy Policy</a></li>
                    </ul>
                </div> <!-- end of col -->
                <div class="col-lg-6">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                    <p>
                        <a href="/">Hysteria2官网订阅站</a> 版权所有 Powered by WordPress
                    </p>
                </div> <!-- end of col -->
            </div> <!-- enf of row -->
        </div> <!-- end of container -->
    </div> <!-- end of copyright -->
    <!-- end of copyright -->
    <!-- Back To Top Button -->
    <button onclick="topFunction()" id="myBtn">
        <img href="/assets/website/img/hysteria2/up-arrow.png" alt="alternative">
    </button>
    <!-- end of back to top button -->
    <!-- Scripts -->
    <script src="/assets/website/js/frontend/hysteria2/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/hysteria2/bootstrap.min.js"></script> <!-- Bootstrap framework -->
    <script src="/assets/website/js/frontend/hysteria2/swiper.min.js"></script> <!-- Swiper for image and text sliders -->
    <script src="/assets/website/js/frontend/hysteria2/purecounter.min.js"></script> <!-- Purecounter counter for statistics numbers -->
    <script src="/assets/website/js/frontend/hysteria2/isotope.pkgd.min.js"></script> <!-- Isotope for filter -->
    <script src="/assets/website/js/frontend/hysteria2/scripts.js"></script> <!-- Custom scripts -->
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>